%%

[ \t]				; // ignore whitespace
\n					{ ++lineNum; std::cout << std::endl; } // increment line num
[0-9]+\.[0-9]+		{ std::cout << "Found a float: " << yytext << std::endl; ++wordsNum; }
[0-9]+				{ std::cout << "Found an integer: " << yytext << std::end; ++wordsNum; }
[a-zA-Z][a-zA-Z0-9]* {std::cout << "Found a string: " << yytext << std::endl; ++wordsNum; }

%

int main(int argc, char**argv) {
	yylex():
}





to run:
flex basic.l
g++ -I lex.yy.c -lfl

backus-naur tree


defining a grammar
prog:
	multiline
multiline:
	line '\n' multiline
line:
	PRINTLINE
    | EXPRESSIONLINE

mathematically: 
capital letters in english are non-terminal, 
greek letters are things like newline
A -> alpha Bgamma
B -> alpha alphaB
B -> alpha deltaC
C -> theta

this is a grammar, a language is all terminal things that can be generated by the grammar
alpha (alpha alpha)* alpha delta theta gamma is the language generated by the grammar

context free: only non-terminal characters on the "left"
context sensitive: terminals can be on the "left"

we're using yacc (yet another compiler-compiler)

install 
flex
flex-devel
bison
